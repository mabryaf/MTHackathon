# -*- coding: utf-8 -*-
"""SmartQueue v0.4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Pvcqcg3XtA_JhshkWWkx_6Bk7RkpKJAW
"""

# advanced date data types
# ! pip install arrow

from random import randrange  # to simulate occupancy sensor and queue times
import random  # simulate the assignment of addresses
import unittest
import uuid  # unique IDs for queues
import arrow  # advanced date data types
from enum import Enum  # for reservation states

def sim_occupancy_sensor():
  occupants = randrange(50)
  return occupants

def random_datetime():
  Year = '2020'
  Month = str(randrange(1,12)).zfill(2)
  Day = str(str(randrange(1,28)).zfill(2))
  Hour = str(randrange(23)).zfill(2)
  Minute = str(randrange(59)).zfill(2)

  Date = Year +'-' + Month + '-' + Day + ' ' + Hour + ':' + Minute
  return arrow.get(Date, 'YYYY-MM-DD HH:mm')

def queue(address, destination, resource_id):
  QUEUE_SPAN_IN_MINS = 10
  id = uuid.uuid1().hex
  start = random_datetime()
  end = start.shift(minutes=+QUEUE_SPAN_IN_MINS)
  max = 10
  return {'queue_id':id, 'start_datetime':start, 'end_datetime':end, 'max_capacity':max, 'address':address, 'destination':destination, 'resource_id':resource_id}

def random_address():
  addresses = ["Address A", "Address B", "Address C", "Address D"]
  return random.choice(addresses)

def location(resource_id):
  NUM_QUEUES = 3
  address = random_address()
  destination = 'destination1'
  
  queues = []
  for i in range(0,NUM_QUEUES):
    queues.append(queue(address, destination, resource_id))
  
  return {'address':address, 'max_capacity':10, 'queues':queues}

def resource():
  NUM_LOCATIONS = 3
  resource_id = uuid.uuid1().hex
  max = 50
  sensor = sim_occupancy_sensor

  locations = []
  for i in range(0, NUM_LOCATIONS):
    locations.append(location(resource_id))
  
  return {'resource_id':resource_id, 'max_occupancy':max, 'occupancy_sensor':sensor, 'locations':locations}

def queue_schedule():
  NUM_RESOURCES = 3
  resources = []
  for i in range(0, NUM_RESOURCES):
    resources.append(resource())

  return resources

queue_schedule = queue_schedule()

class TestThatQueueScheduleHasStructureAndContent(unittest.TestCase):
  def test_for_resource_structure_and_content(self):
    self.assertTrue(len(queue_schedule) > 2)
  
  def test_for_resource_location_structure_and_content(self):
    self.assertTrue(len(queue_schedule[1]['locations']) > 2)

  def test_for_resource_location_queue_structure_and_content(self):
    self.assertTrue(len(queue_schedule[2]['locations'][1]['queues']) > 2)

  def test_relationships_between_queue_location_and_resource(self):
    self.assertEqual(queue_schedule[0]['locations'][0]['queues'][0]['address'], queue_schedule[0]['locations'][0]['address'])
    self.assertEqual(queue_schedule[0]['locations'][0]['queues'][0]['resource_id'], queue_schedule[0]['resource_id'])

class TestDataTypesOfQueueSchedule(unittest.TestCase):
  def test_data_types_of_resource_attributes(self):
    self.assertTrue(isinstance(queue_schedule[0]['resource_id'], str))
    self.assertTrue(isinstance(queue_schedule[0]['max_occupancy'], int))
    self.assertTrue(isinstance(queue_schedule[0]['occupancy_sensor'](), int))
  
  def test_data_types_of_location_attributes(self):
    self.assertTrue(isinstance(queue_schedule[0]['locations'], list))
    self.assertTrue(isinstance(queue_schedule[0]['locations'][0], dict))
    self.assertTrue(isinstance(queue_schedule[0]['locations'][0]['address'], str))
    self.assertTrue(isinstance(queue_schedule[0]['locations'][0]['max_capacity'], int))
    self.assertTrue(isinstance(queue_schedule[0]['locations'][0]['queues'], list))
  
  def test_data_types_of_queue_attributes(self):
    self.assertTrue(isinstance(queue_schedule[0]['locations'][0]['queues'][0]['queue_id'], str))
    self.assertTrue(isinstance(queue_schedule[0]['locations'][0]['queues'][0]['start_datetime'], arrow.arrow.Arrow))
    self.assertTrue(isinstance(queue_schedule[0]['locations'][0]['queues'][0]['end_datetime'], arrow.arrow.Arrow))
    self.assertNotEqual(queue_schedule[0]['locations'][0]['queues'][0]['start_datetime'].format('YYYY'),'0001')
    self.assertNotEqual(queue_schedule[0]['locations'][0]['queues'][0]['end_datetime'].format('YYYY'),'0001')
    self.assertTrue(isinstance(queue_schedule[0]['locations'][0]['queues'][0]['address'], str))
    self.assertTrue(isinstance(queue_schedule[0]['locations'][0]['queues'][0]['resource_id'], str))


unittest.main(argv=[''], verbosity=2, exit=False)

class ReservationState(Enum):
  RESERVED = 1
  CANCELED = 2
  MISSED = 3
  COMPLETED = 4
  TERMINATED = 5

class Reservation:
  def __init__(self, person_id, occupants, reward_points):
    self.id = uuid.uuid1()
    self.person_id = person_id
    self.state = ReservationState.RESERVED
    self.reward_points = reward_points
    self.occupants = occupants
  
  def update(self, new_state):
    self.state = new_state

class TestReservation(unittest.TestCase):
  def setUp(self):
    person_id = "abc123"
    occupants = 3
    reward_points = 3
    self.reservation = Reservation(person_id, occupants, reward_points)

  def test_reservation_creation(self):
    self.assertEqual(self.reservation.person_id, "abc123")
    self.assertEqual(self.reservation.state, ReservationState.RESERVED)
    self.assertEqual(self.reservation.reward_points, 3)
    self.assertEqual(self.reservation.occupants, 3)
  
  def test_reservation_update(self):
    self.reservation.update(ReservationState.COMPLETED)
    self.assertEqual(self.reservation.state, ReservationState.COMPLETED)

unittest.main(argv=[''], verbosity=2, exit=False)

class QueueStatus(Enum):
  ACTIVE = 1
  TERMINATED = 2

class ReserveActionResult(Enum):
  SUCCESS = 1
  DOUBLE_BOOKING_FAILURE = 2
  OTHER_FAILURE = 3

class Queue:
  def __init__(self, queue_id, max_capacity, open_datetime, close_datetime, address, destination, resource_id):
    self.id =  queue_id
    self.open_datetime = arrow.get(open_datetime)
    self.close_datetime = arrow.get(close_datetime)
    self.max_capacity = max_capacity
    self.address = address
    self.destination = destination
    self.resource_id = resource_id
    self.reservations = []
    self.status = QueueStatus.ACTIVE
    self.__active_reservation_states = [ReservationState.RESERVED, ReservationState.COMPLETED]

  def terminate(self):
    for reservation in self.reservations:
      if reservation.state in self.__active_reservation_states:
        reservation.state = ReservationState.TERMINATED
    self.status = QueueStatus.TERMINATED

  def __reservation_is_active (self, reservation):
    reservation_active = reservation.state in self.__active_reservation_states
    return reservation_active
  
  def active_occupants(self):
    active_occupants = 0
    for reservation in self.reservations:
      if (self.__reservation_is_active(reservation)): 
        active_occupants += reservation.occupants
    return active_occupants

  def remaining_capacity(self, remaining_resource_capacity, remaining_location_capacity):
    remaining_queue_capacity = self.max_capacity - self.active_occupants()
    return min(remaining_location_capacity, remaining_resource_capacity, remaining_queue_capacity)

  def reward(self, remaining_resource_capacity, remaining_location_capacity):
    remaining_capacity = self.remaining_capacity(remaining_location_capacity, remaining_resource_capacity)
    max_capacity = self.max_capacity
    return remaining_capacity/max_capacity

  def __find_reservation(self, person_id):
    reservation_found = None
    for reservation in self.reservations:
      if (reservation.person_id == person_id):
        reservation_found = reservation
    return reservation_found

  def __remaining_queue_capacity(self):
    return self.max_capacity - self.active_occupants()

  def reservation(self, person_id):
    return self.__find_reservation(person_id)

  def reserve(self, person_id, proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity):
    remaining_capacity = self.remaining_capacity(remaining_location_capacity, remaining_resource_capacity)
    capacity_remains = remaining_capacity >= occupants

    result_code = ReserveActionResult.OTHER_FAILURE
    reservation_is_new = self.__find_reservation(person_id) is None
    queue_is_active = self.status == QueueStatus.ACTIVE

    if reservation_is_new and capacity_remains and queue_is_active:
      res = Reservation(person_id, occupants, reward_points)
      self.reservations.append(res)
      result_code = ReserveActionResult.SUCCESS

    result = {
        'code':result_code,
        'remaining_resource_capacity':remaining_resource_capacity,
        'remaining_queue_capacity':remaining_capacity,
        'reward_points':reward_points
        }
    
    return result
  
  def __update_reservation (self, reservation, state):
    reservation.state = state
    
  def cancel_reservation(self, person_id):
    res = self.__find_reservation(person_id)
    reservation_found = not (res is None)
    if reservation_found:
      self.__update_reservation(res, ReservationState.CANCELED)

  def complete_reservation(self, person_id):
    res = self.__find_reservation(person_id)
    reservation_found = not (res is None)
    if reservation_found and self.__reservation_is_active(res):
      self.__update_reservation(res, ReservationState.COMPLETED)
  
  def miss_reservation(self, person_id):
    res = self.__find_reservation(person_id)
    reservation_found = not (res is None)
    reserved = (res.state == ReservationState.RESERVED)
    if reservation_found and reserved:
      self.__update_reservation(res, ReservationState.MISSED)

class TestQueue(unittest.TestCase):
  def setUp(self):
    open = arrow.get('2020-07-04 13:00', 'YYYY-MM-DD HH:mm')
    close = open.shift(minutes=+10)
    address = "123main"
    destination = 'destination1'
    resource_id = "resource1"
    self.queue = Queue("queue", 10, open, close, address, destination, resource_id)

  def test_queue_creation(self):
    self.assertTrue(isinstance(self.queue.id, str))
    self.assertTrue(isinstance(self.queue.open_datetime, arrow.arrow.Arrow))
    self.assertNotEqual(self.queue.open_datetime.format('YYYY'),'0001')
    self.assertTrue(isinstance(self.queue.close_datetime, arrow.arrow.Arrow))
    self.assertNotEqual(self.queue.close_datetime.format('YYYY'),'0001')
    self.assertEqual(self.queue.max_capacity, 10)
    self.assertEqual(self.queue.active_occupants(), 0)
    self.assertEqual(self.queue.address, '123main')
    self.assertEqual(self.queue.resource_id, 'resource1')

  def test_making_reservations(self):
    proof_of_purchase = 'purchase'
    occupants = 2
    reward_points = 0
    remaining_resource_capacity = 10
    remaining_location_capacity = 10

    result = self.queue.reserve("abc123", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.assertEqual(result['code'], ReserveActionResult.SUCCESS)
    self.assertEqual(self.queue.active_occupants(), 2)

    #the queue should ignore duplicate reservation requests
    result = self.queue.reserve("abc123", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.assertEqual(result['code'], ReserveActionResult.OTHER_FAILURE)
    self.assertEqual(self.queue.active_occupants(), 2)

    #active queues should honor new reservation requests
    occupants = 3
    self.queue.reserve("xyz456", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.queue.reserve("ijk789", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.assertEqual(self.queue.active_occupants(), 8)

    #terminated queues should not honor new reservation requests
    self.queue.terminate()
    self.queue.reserve("def789", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.assertEqual(result['code'], ReserveActionResult.OTHER_FAILURE)

    #there should be no active occupants in a terminated queue
    #you cannot make new reservations in a terminated queue
    self.assertEqual(self.queue.active_occupants(), 0)

  def test_canceling_reservations(self):
    proof_of_purchase = 'purchase'
    occupants = 3
    reward_points = 0
    remaining_resource_capacity = 10
    remaining_location_capacity = 10

    self.queue.reserve("abc123", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.queue.reserve("xyz456", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.queue.reserve("ijk789", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.assertEqual(self.queue.active_occupants(), 9)
    
    #canceling a reservation decreases active occupants
    self.queue.cancel_reservation("abc123")
    self.assertEqual(self.queue.active_occupants(), 6)

    #it is meaningless to cancel a non-existent reservation
    self.queue.cancel_reservation("nonexistent")
    self.assertEqual(self.queue.active_occupants(), 6)

    #it is meaningless to cancel rervations for a terminated queue
    self.queue.terminate()
    self.assertEqual(self.queue.active_occupants(), 0)
    self.queue.cancel_reservation("xyz456")
    self.assertEqual(self.queue.active_occupants(), 0)


  def test_completing_reservations(self):
    proof_of_purchase = 'purchase'
    occupants = 2
    reward_points = 0
    remaining_resource_capacity = 10
    remaining_location_capacity = 10

    self.queue.reserve("abc123", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.queue.reserve("xyz456", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.queue.reserve("ijk789", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.assertEqual(self.queue.active_occupants(), 6)

    #complete reservations remain active
    self.queue.complete_reservation("xyz456")
    self.assertEqual(self.queue.active_occupants(), 6)

    #you cannot complete a canceled reservation
    self.queue.cancel_reservation("abc123")
    self.queue.complete_reservation("abc123")
    self.assertEqual(self.queue.active_occupants(), 4)

    #you cannot complete a missed reservation
    self.queue.miss_reservation("ijk789")
    self.queue.complete_reservation("ijk789")
    self.assertEqual(self.queue.active_occupants(), 2)
    
    #you cannot complete a terminated reservation
    self.queue.reserve("aaa111", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.assertEqual(self.queue.reservation("aaa111").state, ReservationState.RESERVED)
    self.queue.terminate()
    self.assertEqual(self.queue.reservation("aaa111").state, ReservationState.TERMINATED)
    self.queue.complete_reservation("aaa111")
    self.assertEqual(self.queue.reservation("aaa111").state, ReservationState.TERMINATED)

  def test_missing_reservations(self):
    proof_of_purchase = 'purchase'
    occupants = 1
    reward_points = 0
    remaining_resource_capacity = 10
    remaining_location_capacity = 10

    self.queue.reserve("abc123", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.queue.reserve("xyz456", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.queue.reserve("ijk789", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.queue.reserve("def321", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.assertEqual(self.queue.active_occupants(), 4)

    #you cannot miss a canceled reservation
    self.queue.cancel_reservation("abc123")
    self.queue.miss_reservation("abc123")
    res = self.queue.reservation("abc123")
    self.assertEqual(res.state, ReservationState.CANCELED)

    #you cannot miss a completed reservation
    self.queue.complete_reservation("xyz456")
    self.queue.miss_reservation("xyz456")
    res = self.queue.reservation("xyz456")
    self.assertEqual(res.state, ReservationState.COMPLETED)

    #you can miss a rerserved reservation
    self.queue.miss_reservation("ijk789")
    res = self.queue.reservation("ijk789")
    self.assertEqual(res.state, ReservationState.MISSED)

    #you can miss a missed reservation
    self.queue.miss_reservation("def321")
    self.queue.miss_reservation("def321")
    res = self.queue.reservation("def321")
    self.assertEqual(res.state, ReservationState.MISSED)

    #you cannot miss a terminated reservation
    self.queue.reserve("aaa111", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.queue.terminate()
    self.assertEqual(self.queue.reservation("aaa111").state, ReservationState.TERMINATED)
    self.queue.miss_reservation("aaa111")
    self.assertEqual(self.queue.reservation("aaa111").state, ReservationState.TERMINATED)


  def test_terminating_queues(self):
    proof_of_purchase = 'purchase'
    occupants = 1
    reward_points = 0
    remaining_resource_capacity = 10
    remaining_location_capacity = 10

    self.queue.reserve("abc123", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.queue.reserve("xyz456", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.queue.reserve("ijk789", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.queue.reserve("def321", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)

    #all active reservations on a terminated queue must be terminated
    self.assertEqual(self.queue.reservation("abc123").state, ReservationState.RESERVED)
    self.assertEqual(self.queue.reservation("xyz456").state, ReservationState.RESERVED)
    self.assertEqual(self.queue.reservation("ijk789").state, ReservationState.RESERVED)
    self.assertEqual(self.queue.reservation("def321").state, ReservationState.RESERVED)
    self.queue.terminate()
    self.assertEqual(self.queue.reservation("abc123").state, ReservationState.TERMINATED)
    self.assertEqual(self.queue.reservation("xyz456").state, ReservationState.TERMINATED)
    self.assertEqual(self.queue.reservation("ijk789").state, ReservationState.TERMINATED)
    self.assertEqual(self.queue.reservation("def321").state, ReservationState.TERMINATED)

    #you cannot make a new reservation on a terminated queue
    result = self.queue.reserve("aaa111", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.assertEqual(result['code'], ReserveActionResult.OTHER_FAILURE)

  def test_terminating_reservations(self):
    proof_of_purchase = 'purchase'
    occupants = 1
    reward_points = 0
    remaining_resource_capacity = 10
    remaining_location_capacity = 10

    self.queue.reserve("abc123", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.queue.miss_reservation("abc123")

    self.queue.reserve("xyz456", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.queue.cancel_reservation("xyz456")

    self.queue.reserve("ijk789", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.queue.complete_reservation("ijk789")

    self.queue.terminate()

    #you cannot terminate a missed reservation
    self.assertEqual(self.queue.reservation("abc123").state, ReservationState.MISSED)

    #you cannot terminate a canceled reservation
    self.assertEqual(self.queue.reservation("xyz456").state, ReservationState.CANCELED)

    #you can terminate a completed reservation
    self.assertEqual(self.queue.reservation("ijk789").state, ReservationState.TERMINATED)

  def test_queue_capacity(self):
    proof_of_purchase = 'purchase'
    occupants = 1
    reward_points = 0

    #you cannot reserve past the resource capacity
    remaining_resource_capacity = 2
    remaining_location_capacity = 5
    self.queue.reserve("person1", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.queue.reserve("person2", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)

    remaining_resource_capacity = 0
    remaining_location_capacity = 3
    self.queue.reserve("person3", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.assertEqual(self.queue.active_occupants(), 2)

    #you cannot reserve past the location capacity
    remaining_resource_capacity = 2
    remaining_location_capacity = 5
    self.queue.reserve("person3", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)

    remaining_resource_capacity = 1
    remaining_location_capacity = 0
    self.queue.reserve("person4", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.assertEqual(self.queue.active_occupants(), 3)

    #you cannot reserve past the queue capacity
    occupants = 3
    remaining_resource_capacity = 10
    remaining_location_capacity = 10
    self.queue.reserve("person4", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.queue.reserve("person5", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.queue.reserve("person6", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.assertEqual(self.queue.active_occupants(), 9)
  
  def test_reward_points_calculation_of_a_queue(self):
    proof_of_purchase = 'purchase'
    occupants = 1
    remaining_resource_capacity = 10
    remaining_location_capacity = 10

    #a high-capacity queue is worth a lot
    high_reward = self.queue.reward(remaining_resource_capacity, remaining_location_capacity)
    self.assertEqual(high_reward, 1.0)

    #a lower-capacity queue is worth less
    stubbed_reward_points  = 1
    self.queue.reserve("person1", proof_of_purchase, occupants, stubbed_reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.queue.reserve("person2", proof_of_purchase, occupants, stubbed_reward_points, remaining_resource_capacity, remaining_location_capacity)
    middle_reward = self.queue.reward(remaining_resource_capacity, remaining_location_capacity)
    self.assertEqual(middle_reward, 0.8)

    #the resource capacity affects the queue reward
    remaining_resource_capacity = 2
    little_reward = self.queue.reward(remaining_resource_capacity, remaining_location_capacity)
    self.assertEqual(little_reward, 0.2)

    #the location capacity affects the queue reward
    remaining_location_capacity = 0
    no_reward = self.queue.reward(remaining_resource_capacity, remaining_location_capacity)
    self.assertEqual(no_reward, 0.0)

unittest.main(argv=[''], verbosity=2, exit=False)

def ranges_overlap(r1_start, r1_end, r2_start, r2_end):
  r1_start = arrow.get(r1_start)
  r2_start = arrow.get(r2_start)
  r1_end = arrow.get(r1_end)
  r2_end = arrow.get(r2_end)
  starts_overlap = (r1_start >= r2_start) and (r1_start <= r2_end)
  ends_overlap = (r1_end >= r2_start) and (r1_end <= r2_end)
  r1_is_a_superset = (r1_start <= r2_start) and (r1_end >= r2_end)

  ranges_overlap = starts_overlap or ends_overlap or r1_is_a_superset
  return ranges_overlap

class Location:
  def __init__(self, address, max_capacity):
    self.address = address
    self.max_capacity = max_capacity
    self.queues = []

  def add_queue(self, queue):
    self.queues.append(queue)
  
  def remaining_capacity(self, start_datetime, end_datetime):
    occupants_scheduled_to_be_at_location = 0
    for queue in self.queues:
      queue_in_range = ranges_overlap(arrow.get(start_datetime), arrow.get(end_datetime), queue.open_datetime, queue.close_datetime)

      if queue_in_range:
        occupants_scheduled_to_be_at_location += queue.active_occupants()
      
    return self.max_capacity - occupants_scheduled_to_be_at_location

class TestLocation(unittest.TestCase):
  def setUp(self):
    address = "123 Main St"
    max_capacity = 50
    self.location = Location(address, max_capacity)

  def test_location_creation(self):
    self.assertEqual(self.location.address,'123 Main St')
    self.assertEqual(self.location.max_capacity,50)

  def test_adding_queues(self):
    self.assertEqual(len(self.location.queues),0)

    open = arrow.get('2020-07-04 13:00', 'YYYY-MM-DD HH:mm')
    close = open.shift(minutes=+10)
    address = '123main'
    destination = 'dest'
    resource_id = 'resource1'
    queue = Queue("queue", 5, open, close, address, destination, resource_id)
    self.location.add_queue(queue)

    self.assertEqual(len(self.location.queues),1)
  
  def test_location_capacity(self):
    #set up 3 overlapping queues and make reservations
    
    default_queue_max_capacity = 5
    remaining_resource_capacity = 10
    address = '123main'
    destination = 'destination1'
    resource_id = 'resource1'
    proof_of_purchase = 'purchase'
    occupants = 1
    reward_points = 10
    
    #queue 1
    queue1_open = arrow.get('2020-07-04 13:00', 'YYYY-MM-DD HH:mm')
    queue1_close = arrow.get('2020-07-04 13:16', 'YYYY-MM-DD HH:mm')
    queue1 = Queue("queue1", default_queue_max_capacity, queue1_open, queue1_close, address, destination, resource_id)
    self.location.add_queue(queue1)
    remaining_location_capacity = self.location.remaining_capacity(queue1_open, queue1_close)
    self.location.queues[0].reserve("person1", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    
    #queue 2
    queue2_open = arrow.get('2020-07-04 13:05', 'YYYY-MM-DD HH:mm')
    queue2_close = arrow.get('2020-07-04 13:14', 'YYYY-MM-DD HH:mm')
    queue2 = Queue("queue2", default_queue_max_capacity, queue2_open, queue2_close, address, destination, resource_id)
    self.location.add_queue(queue2)
    remaining_location_capacity = self.location.remaining_capacity(queue2_open, queue2_close)
    self.location.queues[1].reserve("person2", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.location.queues[1].reserve("person3", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.location.queues[1].reserve("person4", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)

    #queue 3
    queue3_open = arrow.get('2020-07-04 13:13', 'YYYY-MM-DD HH:mm')
    queue3_close = arrow.get('2020-07-04 13:20', 'YYYY-MM-DD HH:mm')
    queue3 = Queue("queue3", default_queue_max_capacity, queue3_open, queue1_close, address, destination, resource_id)
    self.location.add_queue(queue3)
    remaining_location_capacity = self.location.remaining_capacity(queue3_open, queue3_close)
    self.location.queues[2].reserve("person5", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.location.queues[2].reserve("person6", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)

    #set up a time range that falls within 2 of the queues
    query_start = arrow.get('2020-07-04 13:00', 'YYYY-MM-DD HH:mm')
    query_end = arrow.get('2020-07-04 13:12', 'YYYY-MM-DD HH:mm')

    #test for remaining location capacity given the time range
    self.assertEqual(self.location.remaining_capacity(query_start, query_end), 46)

  def test_location_capacitys_effect_on_queue_capacity(self):
    #create a location with two queues
    self.location.max_capacity = 2
    default_queue_max_capacity = 5
    address ='123main'
    destination = 'destination1'
    resource_id = 'resource1'
    proof_of_purchase = 'purchase'
    occupants = 1
    reward_points = 10
    
    #queue 1
    queue1_open = arrow.get('2020-07-04 13:00', 'YYYY-MM-DD HH:mm')
    queue1_close = arrow.get('2020-07-04 13:16', 'YYYY-MM-DD HH:mm')
    queue1 = Queue("queue1", default_queue_max_capacity, queue1_open, queue1_close, address, destination, resource_id)
    self.location.add_queue(queue1)

    #queue 2
    queue2_open = arrow.get('2020-07-04 13:05', 'YYYY-MM-DD HH:mm')
    queue2_close = arrow.get('2020-07-04 13:14', 'YYYY-MM-DD HH:mm')
    queue2 = Queue("queue2", default_queue_max_capacity, queue2_open, queue2_close, address, destination, resource_id)
    self.location.add_queue(queue2)

    remaining_resource_capacity = 10

    #add to the first queue and check the location's capacity
    remaining_location_capacity = self.location.remaining_capacity(queue1_open, queue1_close)
    self.location.queues[0].reserve("person1", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.assertEqual(self.location.remaining_capacity(queue1_open, queue1_close),1)

    #add to the second queue and check the locations's capacity
    remaining_location_capacity = self.location.remaining_capacity(queue2_open, queue2_close)
    self.location.queues[1].reserve("person2", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.assertEqual(self.location.remaining_capacity(queue2_open, queue2_close),0)

    #attempt to overload the location
    remaining_location_capacity = self.location.remaining_capacity(queue2_open, queue2_close)
    result = self.location.queues[0].reserve("person3", proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    self.assertEqual(result['code'], ReserveActionResult.OTHER_FAILURE)
    self.assertEqual(self.location.remaining_capacity(queue2_open, queue2_close),0)

unittest.main(argv=[''], verbosity=2, exit=False)

class Resource:
  def __init__(self, id, max_occupancy, occupant_sensor):
    self.id = id
    self.capacity = max_occupancy
    self.__occupant_sensor = occupant_sensor

  def occupants(self):
    return self.__occupant_sensor()
  
  def remaining_capacity(self):
    return self.capacity - self.__occupant_sensor()

class TestResource(unittest.TestCase):
  def setUp(self):
    id = "resource1"
    max_occupancy = 10
    occupant_sensor = sim_occupancy_sensor
    self.resource = Resource(id, max_occupancy, occupant_sensor)
  
  def test_resource_creation(self):
    self.assertEqual(self.resource.id, "resource1")
    self.assertEqual(self.resource.capacity, 10)

  def test_occupant_sensor(self):
    self.assertTrue(0 <= self.resource.occupants() <= 50)

  def test_remaining_capacity(self):
    self.assertTrue(self.resource.remaining_capacity() <= 10)

unittest.main(argv=[''], verbosity=2, exit=False)

class SmartQueue:
  def __init__(self, queue_schedule):
    self.__resources = []
    self.__locations = []
    self.__queues = []
    self.update(queue_schedule)

  def debug_locations(self):
    return self.__locations

  def debug_resources(self):
    return self.__resources

  def debug_queues(self):
    return self.__queues

  def __resource_does_not_exist(self, resource_id):
    exists = False
    for resource in self.__resources:
      if resource.id == resource_id: exists = True
    return not exists
  
  def __location_does_not_exist(self, address):
    exists = False
    for location in self.__locations:
      if location.address.lower() == address.lower(): exists = True
    return not exists

  def __queue_does_not_exist(self, queue_id):
    exists = False
    for queue in self.__queues:
      if queue.id == queue_id: exists = True
    return not exists

  def __add_resource_if_it_does_not_exist(self, resource_id, resource):
    if self.__resource_does_not_exist(resource_id):
      self.__resources.append(resource)

  def __add_location_if_it_does_not_exist(self, address, location):
    if self.__location_does_not_exist(address):
      self.__locations.append(location)

  def __add_queue_if_it_does_not_exist(self, queue_id, queue, address):
    if self.__queue_does_not_exist(queue_id):
      self.__queues.append(queue)
      #add the new queue to the proper location
      location = self.__find_location(address)
      location.add_queue(queue)
  

  def update(self, queue_schedule):
    #update resources
    for resource in queue_schedule:
      resource_id = resource['resource_id']
      max_occupancy = resource['max_occupancy']
      occupant_sensor = dummy_sensor #resource['occupancy_sensor']
      new_resource = Resource(resource_id, max_occupancy, occupant_sensor)
      self.__add_resource_if_it_does_not_exist(resource_id, new_resource)

      #update locations
      for location in resource['locations']:
        address = location['address']
        max_capacity = location['max_capacity']
        new_location = Location(address, max_capacity)
        self.__add_location_if_it_does_not_exist(address, new_location)

        #update queues
        for queue in location['queues']:
          queue_id = queue['queue_id']
          max_capacity = queue['max_capacity']
          start_datetime = queue['start_datetime']
          end_datetime = queue['end_datetime']
          address = queue['address']
          destination = queue['destination']
          new_queue = Queue(queue_id, max_capacity, start_datetime, end_datetime, address, destination, resource_id)
          self.__add_queue_if_it_does_not_exist(queue_id, new_queue, address)

  def __find_location(self, address):
    for location in self.__locations:
      if location.address.lower() == address.lower():
        return location
  
  def __find_resource(self, resource_id):
    for resource in self.__resources:
      if resource.id == resource_id:
        return resource

  @staticmethod
  def __queue_option(queue, reward, resource):
    option =  {
        'queue_id':queue.id, 
        'start_time':queue.open_datetime, 
        'end_time':queue.close_datetime, 
        'resource_id':queue.resource_id, 
        'address':queue.address, 
        'destination':queue.destination,
        'reward': reward,
        'queue_percentage': queue.active_occupants()/queue.max_capacity,
        'train_percentage': resource.occupants()/resource.capacity,
        'max_capacity':queue.max_capacity
        }
    return option
  
  def list_queue_options(self, resource_id, address, destination, start_datetime, end_datetime):
    options = []
    for queue in self.__queues:
      #determine if the queue matches criteria
      # resource_matches = (queue.resource_id == resource_id)
      location_matches = (queue.address.lower() == address.lower())
      destination_matches = (queue.destination.lower() == destination.lower())
      time_matches = ranges_overlap(start_datetime, end_datetime, queue.open_datetime, queue.close_datetime)
      queue_matches = location_matches and destination_matches and time_matches

      #determine if the queue has capacity
      resource = self.__find_resource(queue.resource_id)
      remaining_resource_capacity = resource.remaining_capacity()
      location = self.__find_location(queue.address)
      remaining_location_capacity = location.remaining_capacity(start_datetime, end_datetime)
      remaining_queue_capacity = queue.remaining_capacity(remaining_resource_capacity, remaining_location_capacity)
      queue_has_capacity = remaining_queue_capacity > 0

      str_remaining_resource_capacity = str(remaining_resource_capacity)
      str_remaining_location_capacity = str(remaining_location_capacity)
      str_remaining_queue_capacity = str(remaining_queue_capacity)

      queue_has_capacity = remaining_queue_capacity > 0

      if (queue_matches and queue_has_capacity):
        resource = self.__find_resource(queue.resource_id)
        remaining_resource_capacity = resource.remaining_capacity()

        location = self.__find_location(address)
        remaining_location_capacity = location.remaining_capacity(start_datetime, end_datetime)

        reward_points = queue.reward(remaining_resource_capacity, remaining_location_capacity)
        options.append(self.__queue_option(queue, reward_points, resource))
    
    return options

  def __find_queue(self, queue_id):
    for queue in self.__queues:
      if queue.id == queue_id:
        return queue

  def reserve(self, person_id, proof_of_purchase, occupants, queue_id):
    #TODO: check for overlapping reservations
    queue = self.__find_queue(queue_id)

    resource = self.__find_resource(queue.resource_id)
    remaining_resource_capacity = resource.remaining_capacity()

    location = self.__find_location(queue.address)
    remaining_location_capacity = location.remaining_capacity(queue.open_datetime, queue.close_datetime)

    reward_points = queue.reward(remaining_resource_capacity, remaining_location_capacity)
    result = queue.reserve(person_id, proof_of_purchase, occupants, reward_points, remaining_resource_capacity, remaining_location_capacity)
    return result

  @staticmethod
  def __reservation_details(reservation, queue, resource):

    details = {
        'reservation_id':reservation.id,
        'reservation_state':reservation.state,
        'start_time':queue.open_datetime,
        'end_time':queue.close_datetime,
        'resource':queue.resource_id,
        'address':queue.address,
        'destination':queue.destination,
        'reward_points':reservation.reward_points,
        'queue_percentage': queue.active_occupants()/queue.max_capacity,
        'train_percentage': resource.occupants()/resource.capacity
    }
    return details

  def list_reservations(self, person_id):
    reservations = []
    for queue in self.__queues:
      for reservation in queue.reservations:
        if reservation.person_id == person_id:
          resource = self.__find_resource(queue.resource_id)
          details = self.__reservation_details(reservation, queue, resource)
          reservations.append(details)
    return reservations

  def complete_reservation(self, queue_id, person_id):
    queue = self.__find_queue(queue_id)
    queue.complete_reservation(person_id)

  def cancel_reservation(self, queue_id, person_id):
    queue = self.__find_queue(queue_id)
    queue.cancel_reservation(person_id)

  def miss_reservation(self, queue_id, person_id):
    queue = self.__find_queue(queue_id)
    queue.miss_reservation(person_id)
  
  def terminate_queues_for_a_location_and_timeframe(self, address, start_datetime, end_datetime):
    pass
  
  def terminate_queues_for_a_resource_and_timeframe(self, resource_id):
    pass

  def archive_expired_data(self):
    #TODO:remove exprired queuees
    #TODO:remove unused resources
    #TODO:remove unused locations
    pass

#needed to test the smart queue
def dummy_sensor():
  return 0

class TestSmartQueue(unittest.TestCase):

  def setUp(self):
    queue_schedule = [
                      {'resource_id':'resource1', 
                      'max_occupancy':5, 
                      'occupancy_sensor':dummy_sensor, 
                      'locations':[{'address':'address1', 
                                    'max_capacity':3, 
                                    'queues':[{'queue_id':'queue1', 
                                                'start_datetime':arrow.get('2020-07-06 13:00', 'YYYY-MM-DD HH:mm'), 
                                                'end_datetime':arrow.get('2020-07-06 13:10', 'YYYY-MM-DD HH:mm'), 
                                                'max_capacity':6, 
                                                'address':'address1',
                                                "destination": "destination1",
                                                'resource_id':'resource1'}
                                              ]
                                    }
                                    ]
                      },
                      {'resource_id':'resource2', 
                      'max_occupancy':4, 
                      'occupancy_sensor':dummy_sensor, 
                      'locations':[{'address':'address2', 
                                    'max_capacity':5,   
                                    'queues':[{'queue_id':'queue2', 
                                                'start_datetime':arrow.get('2020-07-06 13:00', 'YYYY-MM-DD HH:mm'), 
                                                'end_datetime':arrow.get('2020-07-06 13:10', 'YYYY-MM-DD HH:mm'), 
                                                'max_capacity':2, 
                                                'address':'address2',
                                                "destination": "destination1",
                                                'resource_id':'resource2'},
                                              {'queue_id':'queue3', 
                                                'start_datetime':arrow.get('2020-07-06 13:10', 'YYYY-MM-DD HH:mm'), 
                                                'end_datetime':arrow.get('2020-07-06 13:20', 'YYYY-MM-DD HH:mm'), 
                                                'max_capacity':3, 
                                                'address':'address2',
                                                "destination": "destination1", 
                                                'resource_id':'resource2'}
                                              ]
                                    }
                                    ]
                      }    
    ]
    
    self.smartqueue = SmartQueue(queue_schedule)
  
  def test_queue_update(self):
    #test adding a new resource
    queue_schedule = [
                      {'resource_id':'resource3', 
                      'max_occupancy':5, 
                      'occupancy_sensor':dummy_sensor, 
                      'locations':[{'address':'address1', 
                                    'max_capacity':3, 
                                    'queues':[{'queue_id':'queue4', 
                                                'start_datetime':arrow.get('2020-07-06 13:00', 'YYYY-MM-DD HH:mm'), 
                                                'end_datetime':arrow.get('2020-07-06 13:10', 'YYYY-MM-DD HH:mm'), 
                                                'max_capacity':6, 
                                                'address':'address1',
                                                "destination": "destination1", 
                                                'resource_id':'resource3'}
                                              ]
                                    }
                                    ]
                      }
    ]
    self.smartqueue.update(queue_schedule)

    start_datetime = arrow.get('2020-07-06 13:00', 'YYYY-MM-DD HH:mm')
    end_datetime = arrow.get('2020-07-06 13:20', 'YYYY-MM-DD HH:mm')
    queue_options = self.smartqueue.list_queue_options('resource3', 'address1', 'destination1', start_datetime, end_datetime)
    self.assertEqual(len(queue_options), 2)

    #test addding a new location
    queue_schedule = [
                      {'resource_id':'resource3', 
                      'max_occupancy':5, 
                      'occupancy_sensor':dummy_sensor, 
                      'locations':[{'address':'address3', 
                                    'max_capacity':3, 
                                    'queues':[{'queue_id':'queue5', 
                                                'start_datetime':arrow.get('2020-07-06 13:00', 'YYYY-MM-DD HH:mm'), 
                                                'end_datetime':arrow.get('2020-07-06 13:10', 'YYYY-MM-DD HH:mm'), 
                                                'max_capacity':6, 
                                                'address':'address3',
                                                'destination': 'destination1',
                                                'resource_id':'resource3'}
                                              ]
                                    }
                                    ]
                      }
    ]
    self.smartqueue.update(queue_schedule)

    start_datetime = arrow.get('2020-07-06 13:00', 'YYYY-MM-DD HH:mm')
    end_datetime = arrow.get('2020-07-06 13:20', 'YYYY-MM-DD HH:mm')
    queue_options = self.smartqueue.list_queue_options('resource3', 'address3', 'destination1', start_datetime, end_datetime)
    self.assertEqual(len(queue_options), 1)

    #ignore duplicate resources and locations
    queue_schedule = [
                      {'resource_id':'resource3', 
                      'max_occupancy':5, 
                      'occupancy_sensor':dummy_sensor, 
                      'locations':[{'address':'address3', 
                                    'max_capacity':3, 
                                    'queues':[{'queue_id':'queue6', 
                                                'start_datetime':arrow.get('2020-07-06 13:00', 'YYYY-MM-DD HH:mm'), 
                                                'end_datetime':arrow.get('2020-07-06 13:10', 'YYYY-MM-DD HH:mm'), 
                                                'max_capacity':6, 
                                                'address':'address1',
                                                'destination': 'destination1',
                                                'resource_id':'resource1'}
                                              ]
                                    }
                                    ]
                      }
    ]

    self.assertEqual(len(self.smartqueue.debug_resources()),3)
    self.assertEqual(len(self.smartqueue.debug_locations()),3)
    self.assertEqual(len(self.smartqueue.debug_queues()),5)

    self.smartqueue.update(queue_schedule)

    self.assertEqual(len(self.smartqueue.debug_resources()),3)
    self.assertEqual(len(self.smartqueue.debug_locations()),3)
    self.assertEqual(len(self.smartqueue.debug_queues()),6)


  def test_queue_options(self):
    #find available queues for resource 1
    start_datetime = arrow.get('2020-07-06 13:00', 'YYYY-MM-DD HH:mm')
    end_datetime = arrow.get('2020-07-06 13:20', 'YYYY-MM-DD HH:mm')
    queue_options = self.smartqueue.list_queue_options('resource1', 'address1', 'destination1', start_datetime, end_datetime)
    self.assertEqual(len(queue_options), 1)

    #make a reservation
    proof_of_purchase = 'proof'
    occupants = 3
    queue_id = queue_options[0]['queue_id']
    result = self.smartqueue.reserve('person1', proof_of_purchase, occupants, queue_id)
    self.assertEqual(result['code'], ReserveActionResult.SUCCESS)

    #find available queues for resource 1
    queue_options = self.smartqueue.list_queue_options('resource1', 'address1', 'destination1', start_datetime, end_datetime)

    #queues with no capacity should not be listed as an option
    self.assertEqual(len(queue_options), 0)


  def test_reservation_creation(self):
    #check that there are no reservations
    reservation_list = self.smartqueue.list_reservations("person1")
    self.assertTrue(isinstance(reservation_list, list))
    self.assertEqual(len(reservation_list), 0)

    #find available queues for resource 1
    start_datetime = arrow.get('2020-07-06 13:00', 'YYYY-MM-DD HH:mm')
    end_datetime = arrow.get('2020-07-06 13:10', 'YYYY-MM-DD HH:mm')
    queue_options = self.smartqueue.list_queue_options('resource1', 'address1', 'destination1', start_datetime, end_datetime)
    self.assertEqual(len(queue_options), 1)

    #make a reservation for resource 1
    proof_of_purchase = 'proof'
    occupants = 1
    queue_id = queue_options[0]['queue_id']
    result = self.smartqueue.reserve('person1', proof_of_purchase, occupants, queue_id)
    self.assertEqual(result['code'], ReserveActionResult.SUCCESS)

    #check that the new reservation exists
    reservation_list = self.smartqueue.list_reservations('person1')
    self.assertEqual(len(reservation_list),1)
    self.assertEqual(reservation_list[0]['resource'],'resource1')

    #find available queues for resource 2
    start_datetime = arrow.get('2020-07-06 13:00', 'YYYY-MM-DD HH:mm')
    end_datetime = arrow.get('2020-07-06 13:20', 'YYYY-MM-DD HH:mm')
    queue_options = self.smartqueue.list_queue_options('resource2', 'address2', 'destination1', start_datetime, end_datetime)
    self.assertEqual(len(queue_options), 2)

    #make a reservation for the first queue option for resource 2
    queue_id = queue_options[0]['queue_id']
    result = self.smartqueue.reserve('person1', proof_of_purchase, occupants, queue_id)
    self.assertEqual(result['code'], ReserveActionResult.SUCCESS)

    #check the remaining reward points of queues for resource 1
    start_datetime = arrow.get('2020-07-06 13:05', 'YYYY-MM-DD HH:mm')
    end_datetime = arrow.get('2020-07-06 13:15', 'YYYY-MM-DD HH:mm')
    queue_options = self.smartqueue.list_queue_options('resource1', 'address1', 'destination1', start_datetime, end_datetime)
    one_third = 1/3
    self.assertEqual(queue_options[0]['reward'],one_third)

    #check the remaining reward points of queues for resource 2
    start_datetime = arrow.get('2020-07-06 12:50', 'YYYY-MM-DD HH:mm')
    end_datetime = arrow.get('2020-07-06 13:11', 'YYYY-MM-DD HH:mm')
    queue_options = self.smartqueue.list_queue_options('resource2', 'address2', 'destination1', start_datetime, end_datetime)
    self.assertEqual(queue_options[0]['reward'],0.5)
    self.assertEqual(queue_options[1]['reward'],1)
  
  def test_double_booking_reservations(self):
    #TODO:
    pass

  def test_queue_termination(self):
    #TODO:
    #make reservations
    #check for the reservations
    #terminate a queue at a location and outside our timeframe
    #the reservation should still exist
    #terminate a queue at a location and inside our timeframe
    #the reservation should be impacted
    #terminate a queue for a resource and outside our timeframe
    #the reservation should still exist
    #terminate a queue for a resource and inside our timeframe
    #the reservation should be impacted
    pass


unittest.main(argv=[''], verbosity=2, exit=False)

testqueue= [
                      {'resource_id':'resource1', 
                      'max_occupancy':5, 
                      'occupancy_sensor':dummy_sensor, 
                      'locations':[{'address':'address1', 
                                    'max_capacity':3, 
                                    'queues':[{'queue_id':'queue1', 
                                                'start_datetime':arrow.get('2020-07-06 13:00', 'YYYY-MM-DD HH:mm'), 
                                                'end_datetime':arrow.get('2020-07-06 13:10', 'YYYY-MM-DD HH:mm'), 
                                                'max_capacity':6, 
                                                'address':'address1',
                                                'destination':'destination1',
                                                'resource_id':'resource1'}
                                              ]
                                    }
                                    ]
                      },
                      {'resource_id':'resource2', 
                      'max_occupancy':4, 
                      'occupancy_sensor':dummy_sensor, 
                      'locations':[{'address':'address2', 
                                    'max_capacity':5, 
                                    'queues':[{'queue_id':'queue2', 
                                                'start_datetime':arrow.get('2020-07-06 13:00', 'YYYY-MM-DD HH:mm'), 
                                                'end_datetime':arrow.get('2020-07-06 13:10', 'YYYY-MM-DD HH:mm'), 
                                                'max_capacity':2, 
                                                'address':'address2',
                                                'destination':'destination1',
                                                'resource_id':'resource2'},
                                              {'queue_id':'queue3', 
                                                'start_datetime':arrow.get('2020-07-06 13:10', 'YYYY-MM-DD HH:mm'), 
                                                'end_datetime':arrow.get('2020-07-06 13:20', 'YYYY-MM-DD HH:mm'), 
                                                'max_capacity':3, 
                                                'address':'address2',
                                                'destination':'destination1',
                                                'resource_id':'resource2'}
                                              ]
                                    }
                                    ]
                      }    
    ]
sq = SmartQueue(testqueue)